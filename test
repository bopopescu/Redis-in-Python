import base64
import click
import contextlib
from fnmatch import fnmatch
import jmespath
import hashlib
import logging
import requests
import pprint
import copy


log = logging.getLogger('c7n-git-ops')

GRAPHQL = 'graphql'
#V3API = 'v3'
V3API = ''

GET_REPOS = """
query($organization: String!, $cursor: String) {
  organization(login: $organization) {
    repositories(first: 100, after: $cursor, orderBy: {field: UPDATED_AT, direction: DESC}){
      edges {
        node {
          name
          url
          createdAt
        }
      }
      pageInfo {
        endCursor
        hasNextPage
      }
    }
  }
}
"""

GIT_MESSAGE = 'Added new file'
GIT_NAME = 'David Shepherd'
GIT_EMAIL = 'David.Shepherd2@capitalone.com'

# The set of functions that do the actual GITHUB work.
#
#   inner_get_file - get a file from the repo.
#   inner_delete_file - delete a file in a repo.


def inner_get_file(github_url, github_token, github_owner, github_repo, target, verbose):
    url = '/'.join((github_url, V3API, 'repos', github_owner, github_repo, 'contents', target))
    auth = {'Authorization': 'token ' + github_token,
            'Accept': 'application/vnd.github.VERSION.object'
           }
    response = requests.get(url, headers=auth)
    results = response.json()
    if response.status_code != 200 or 'errors' in results:
        raise ValueError("Github api error %s" % (
            response.content.decode('utf8'),))
    if verbose:
        pp = pprint.PrettyPrinter(indent=4)
        pp.pprint(results)
    return results


def inner_delete_file(github_url, github_token, github_owner, github_branch, github_repo, target, verbose):

    sha_of_file = inner_get_file(github_url, github_token, github_owner,
                           github_repo, target, 0)['sha']
    url = '/'.join((github_url, V3API, 'repos', github_owner, github_repo, 'contents', target))
    auth = {'Authorization': 'token ' + github_token}
    data = {'message':GIT_MESSAGE,
            'committer':{'name':GIT_NAME, 'email':GIT_EMAIL},
            'sha':sha_of_file}
    response = requests.delete(url, headers=auth, json=data)
    results = response.json()
    if response.status_code != 200 or 'errors' in results:
        raise ValueError("Github api error %s" % (
            response.content.decode('utf8'),))
    if verbose:
        print( response.status_code )

    # We return the 200 for a good return
    return response.status_code


def inner_update_existing_file(github_url, github_token, github_owner, github_repo,
                               github_branch, source, target, verbose):
    sha_of_file = inner_get_file(github_url, github_token, github_owner,
                           github_repo, target, 0)['sha']
    url = '/'.join((github_url, V3API, 'repos',github_owner, github_repo, 'contents', target))
    auth = {'Authorization': 'token ' + github_token}
    file_contents = source.read()
    content = base64.b64encode(file_contents).decode()
    data = {'message':GIT_MESSAGE,
            'committer':{'name':GIT_NAME, 'email':GIT_EMAIL},
            'content':content,
            'sha':sha_of_file,
            'branch': github_branch
           }
    response = requests.put(url, headers=auth, json=data)
    results = response.json()
    if response.status_code != 200 or 'errors' in results:
        raise ValueError("Github api error %s" % (
            response.content.decode('utf8'),))
    if verbose:
        print( response.status_code )
    return response.status_code


def inner_store_new_file(github_url, github_token, github_owner, github_repo,
                   github_branch, source, target, verbose ):
    url = '/'.join((github_url, 'repos', github_owner, github_repo, 'contents', target))
    auth = {'Authorization': 'token ' + github_token}
    content = base64.b64encode(source.read()).decode()
    data = {'message':GIT_MESSAGE,
            'committer': {'name': GIT_NAME, 'email': GIT_EMAIL},
            'content': content,
            'branch': github_branch
           }
    response = requests.put(url, headers=auth, json=data)
    results = response.json()
    if response.status_code != 201 or 'errors' in results:
        raise ValueError("Github api error %s" % (
            response.content.decode('utf8'),))
    if verbose:
        print( response.status_code )

    # We return 200 for a good return even thought Github
    # gives us a 201!
    return requests.codes.ok


def inner_get_protection_status(github_url, github_token, github_branch,
                github_owner, github_repo, verbose):
    """Get protection status
    """
    # Generate the auth header for the all the requests.
    headers = {"Authorization": "token {}".format(github_token)}

    # Make sure branch protection is on for the repo. If not, we probably
    # are some place we don't want to be....
    url = '/'.join((github_url, 'repos', github_owner, github_repo,
                    'branches', github_branch, 'protection'))
    response = requests.get(url, headers=headers)
    results = response.json()
    if response.status_code != 200 or 'errors' in results:
        raise ValueError("Github api error %s" % (
            response.content.decode('utf8'),))
    if verbose:
        pp = pprint.PrettyPrinter(indent=4)
        pp.pprint(results)
    else:
        return response.json()


def inner_set_prot(github_url, github_token, github_owner, github_repo, 
                   github_branch, prot_data, verbose):
    url = '/'.join((github_url, 'repos', github_owner, github_repo, 'branches', github_branch, 'protection'))
    auth = {'Authorization': 'token ' + github_token}
    response = requests.put(url, headers=auth, json=prot_data)
    results = response.json()
    if response.status_code != requests.codes.ok or 'errors' in results:
        raise ValueError("Github api error %s" % (
            response.content.decode('utf8'),))
    if verbose:
        print(response.status_code)
    return response.status_code


def inner_delete_prot(github_url, github_token, github_branch, 
                      github_owner, github_repo, verbose):
    url = '/'.join((github_url, 'repos', github_owner, github_repo, 'branches', github_branch, 'protection'))
    auth = {'Authorization': 'token ' + github_token}
    response = requests.delete(url, headers=auth)
    if response.status_code != 204:
        raise ValueError("Github api error %s" % (
            response.content.decode('utf8'),))
    if verbose:
        print(response.status_code)
    return response.status_code


# These are the publicly accessible command line options for various GITHUB commands
@click.group()
def cli():
    """Git Ops for custodian"""


@cli.command(name='get-file')
@click.option('--github-url', envvar="GITHUB_URL",
              default='https://api.github.com/graphql')
@click.option('--github-token', envvar='GITHUB_TOKEN',
              help="Github credential token")
@click.option('--github-owner', envvar='GITHUB_OWNER',
              help="Github owner")
@click.option('--github-repo', envvar='GITHUB_REPO',
              help='Repo name')
@click.option('--target', help='Target file in repo.')
@click.option('-v', '--verbose', help='Verbose output')
def get_file(github_url, github_token, github_owner, github_repo, target, verbose):
    return inner_get_file(github_url, github_token, github_owner,
                          github_repo, target, verbose)


@cli.command(name='delete-file')
@click.option('--github-url', envvar="GITHUB_URL",
              default='https://api.github.com/graphql')
@click.option('--github-token', envvar='GITHUB_TOKEN',
              help="Github credential token")
@click.option('--github-owner', envvar='GITHUB_OWNER',
              help="Github owner")
@click.option('--github-repo', envvar='GITHUB_REPO',
              help='Repo name')
@click.option('--github-branch', envvar='GITHUB_BRANCH',
              help="Github branch")
@click.option('--target', help='Target file in repo.')
@click.option('-v', '--verbose', help='Verbose output')
def delete_file(github_url, github_token, github_owner, github_branch, github_repo,
                target, verbose):
    return inner_delete_file(github_url, github_token, github_owner,
                            github_branch, github_repo, target, verbose)


@cli.command(name='update-existing-file')
@click.option('--github-url', envvar="GITHUB_URL",
              default='https://api.github.com/graphql')
@click.option('--github-token', envvar='GITHUB_TOKEN',
              help="Github credential token")
@click.option('--github-owner', envvar='GITHUB_OWNER',
              help="Github owner")
@click.option('--github-repo', envvar='GITHUB_REPO',
              help='Repo name')
@click.option('--github-branch', envvar='GITHUB_BRANCH',
              help="Github branch")
@click.option('--source', type=click.File('rb'),
              help='Source file')
@click.option('--target', help='Target file in repo.')
@click.option('-v', '--verbose', help='Verbose output')
def update_existing_file(github_url, github_token, github_owner, github_repo, github_branch, source, target, verbose):
    return inner_update_existing_file(github_url, github_token, github_owner,
                                     github_repo, github_branch, source, target, verbose)


@cli.command(name='store-new-file')
@click.option('--github-url', envvar="GITHUB_URL",
              default='https://api.github.com/graphql')
@click.option('--github-token', envvar='GITHUB_TOKEN',
              help="Github credential token")
@click.option('--github-owner', envvar='GITHUB_OWNER',
              help="Github owner")
@click.option('--github-repo', envvar='GITHUB_REPO',
              help='Repo name')
@click.option('--github-branch', envvar='GITHUB_BRANCH',
              help="Github branch")
@click.option('--source', type=click.File('rb'),
              help='Source file')
@click.option('--target', help='Target file in repo.')
@click.option('-v', '--verbose', help="Verbose output")
def store_new_file(github_url, github_token, github_owner, github_repo,
                   github_branch, source, target, verbose ):
    return inner_store_new_file(github_url, github_token, github_owner,
                                github_repo, github_branch, source, target, verbose)


@cli.command(name='get-protection')
@click.option('--github-url', envvar="GITHUB_URL")
@click.option('--github-token', envvar='GITHUB_TOKEN',
              help="Github credential token")
@click.option('--github-owner', envvar='GITHUB_OWNER',
              help="Github owner")
@click.option('--github-repo', envvar='GITHUB_REPO',
              help='Repo name')
@click.option('--github-branch', envvar='GITHUB_BRANCH',
              help="Github branch")
@click.option('-v', '--verbose', help="Verbose output")
def get_protection_status(github_url, github_token, github_branch,
                github_owner, github_repo, verbose):

    return inner_get_protection_status(github_url, github_token,
                                      github_branch, github_owner,
                                      github_repo, verbose)


@cli.command(name='delete-protection')
@click.option('--github-url', envvar="GITHUB_URL")
@click.option('--github-token', envvar='GITHUB_TOKEN',
              help="Github credential token")
@click.option('--github-owner', envvar='GITHUB_OWNER',
              help="Github owner")
@click.option('--github-repo', envvar='GITHUB_REPO',
              help='Repo name')
@click.option('--github-branch', envvar='GITHUB_BRANCH',
              help="Github branch")
@click.option('-v', '--verbose', help="Verbose output")
def get_protection_status(github_url, github_token, github_branch,
                github_owner, github_repo, verbose):

    return inner_delete_prot(github_url, github_token,
                                      github_branch, github_owner,
                                      github_repo, verbose)


@cli.command(name='set-protection')
@click.option('--github-url', envvar="GITHUB_URL",
              default='https://api.github.com/graphql')
@click.option('--github-token', envvar='GITHUB_TOKEN',
              help="Github credential token")
@click.option('--github-owner', envvar='GITHUB_OWNER',
              help="Github owner")
@click.option('--github-repo', envvar='GITHUB_REPO',
              help='Repo name')
@click.option('--github-branch', envvar='GITHUB_BRANCH',
              help="Github branch")
@click.option('-v', '--verbose', help="Verbose output")
def set_prot(github_url, github_token, github_owner, github_repo, 
             github_branch, prot_data, verbose):
    return inner_set_prot(github_url, github_token, github_owner, github_repo, 
             github_branch, prot_data, verbose)


def process_prot_data(orig_prot):
    """
    Take the branch protection data taken from a get-protection
    call and turn it into data that can be used by set-protection.
    """
    # Give us a copy of the source data
    data = copy.copy(orig_prot)
    for i in orig_prot.keys():
        # Essentially we are removing all occurrences of data
        # items that have names url and contexts_url. We also
        # simplify the enforce_admins item.
        if i == 'url':
            del data[i]
            continue
        if i == 'enforce_admins':
            data['enforce_admins'] = data['enforce_admins']['enabled']
            continue
        if 'url' in data[i]:
            del data[i]['url']
        if 'contexts_url' in data[i]:
            del data[i]['contexts_url']
    return data


class branch_protection():
    def __init__(self, r, github_url, github_token, github_owner, github_branch):
        self.repo = r
        self.url = github_url
        self.token = github_token
        self.owner = github_owner
        self.branch = github_branch

    def __enter__(self):
        """Toggle branch protection as a context manager"""

        # Generate the auth header for the all the requests.
        headers = {"Authorization": "token {}".format(github_token)}

        # Make sure branch protection is on for the repo. If not, we probably
        # are some place we don't want to be....
        url = '/'.join((github_url, V3API, 'repos', github_owner, repo['name'],
                        'branches', github_branch, 'protection'))
        response = requests.get(url, headers=headers)
        self.protection = response.json()
        if response.status_code != 200 or 'errors' in self.protection:
            raise ValueError("Github api error %s" % (
                response.content.decode('utf8'),))

        # We have a valid repo with protection. So here is where we turn it
        # off. This is before we enter the main part of the code where we
        # update the file.
        url = '/'.join((github_url, V3API, 'repos', github_owner, repo['name'],
                        'branches', github_branch, 'protection'))
        response = requests.delete(url, headers=headers)
        result = response.json()
        if response.status_code != 200 or 'errors' in result:
            raise ValueError("Github api error %s" % (
                response.content.decode('utf8'),))

        # If we get here, things are cool - we have a valid repo and
        # we have turned off protection.
        return repo

    def __exit__(self, *args):
        # We have to turn on protection for the repo we just setup.
        #TODO
        pass


def github_repos(organization, github_url, github_token):
    """Return all github repositories in an organization."""
    # Get github repos
    headers = {"Authorization": "token {}".format(github_token)}
    next_cursor = None

    while next_cursor is not False:
        params = {'query': GET_REPOS, 'variables': {
            'organization': organization, 'cursor': next_cursor}}
        response = requests.post('/'.join((github_url, GRAPHQL)), headers=headers, json=params)
        result = response.json()
        if response.status_code != 200 or 'errors' in result:
            raise ValueError("Github api error %s" % (
                response.content.decode('utf8'),))

        repos = jmespath.search(
            'data.organization.repositories.edges[].node', result)
        for r in repos:
            yield r
        page_info = jmespath.search(
            'data.organization.repositories.pageInfo', result)
        if page_info:
            next_cursor = (page_info['hasNextPage'] and
                           page_info['endCursor'] or False)
        else:
            next_cursor = False


def filtered_repos(repos, include, exclude):
    for r in repos:
        if include:
            found = False

            for f in include:
                if fnmatch(r['name'], f):
                    found = True
                    break
            if not found:
                continue

        if exclude:
            found = False
            for e in exclude:
                if fnmatch(r['name'], e):
                    found = True
                    break
            if found:
                continue
        yield r


@cli.command(name='update-files')
@click.option('--organization', envvar="GITHUB_ORG",
              required=True, help="Github Organization")
@click.option('--github-url', envvar="GITHUB_API_URL",
              default='https://api.github.com/graphql')
@click.option('--github-token', envvar='GITHUB_TOKEN',
              help="Github credential token")
@click.option('--branch', envvar='GITHUB_BRANCH',
              help="Github branch")
@click.option('--owner', envvar='GITHUB_OWNER',
              help="Github owner")
@click.option('--source', type=click.File('rb'))
@click.option('--target')
@click.option('-v', '--verbose', help="Verbose output")
@click.option('-i', '--include', multiple=True)
@click.option('-e', '--exclude', multiple=True)
def update_files(organization, github_url, github_token, branch,
                owner, include, exclude, verbose,
                source, target):
    """Update filecustodian-emr-invalid-asv-mark-hourly
    """
    logging.basicConfig(level=verbose and logging.INFO or logging.DEBUG)
    logging.getLogger('urllib3').setLevel(logging.WARNING)
    for r in filtered_repos(
            github_repos(organization, github_url, github_token),
            include, exclude):

        with branch_protection(r, github_url, github_token, owner, branch) as repo:
            # Get the contents of the create the digest hash and encode the contents
            # of the file using base64.
            contents = source.read().encode('utf8')
            digest = hashlib.md5(contents).hexdigest()
            encoded = base64.b64encode(contents)

            # Now upload the file to

def list_prs(include, exclude):
    """Show open pull requests on repos
    """


if __name__ == '__main__':
    cli()




